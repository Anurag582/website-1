---
output: github_markdown
---

```{r message = FALSE}
library("tidyverse")
```


# Recap from Unit I: Global Climate Change

In Unit I, we tackled one of the fundamental skills of data science: working with messy data.  

## Computation

- Comfortable with readr, ggplot, dplyr, some tidyr


## Scientific

- Explored and visualized the actual time series data for 5 key indicators of global warming: CO2 (both present-day and historical ice core record), temperature record, land ice mass, sea ice, and sea level rise.  
- Raw vs Derived data, missing values, resolution, uncertainty
- Saw what real data documentation (and absence there-of) looks like.  

## Statistical

- Moving averages to find trends
- Role of sampling frequency / resolution



# Intro to Unit II: Population Dynamics


In this unit, we shift gears to the opposite end of the spectrum: _simulation_.  Simulation helps us think about **WHY** things happen the way they do.   


This module lays the foundations for population dynamics modeling while providing ample opportunity to practice fundamentals in coding: functions, loops, creating/representing data in a `data.frame` / `tibble` objects, random number generation and plotting.


## Mathematical disclaimer

Many of the models we will be analyzing in this section are analytically tractable with sufficient background in calculus, linear algebra, and differential equations.  However, it doesn't take much modification before these models are no longer tractable in closed form.  We shall not be worrying about any of that here, and focus on simulation, so don't worry if your last calculus class was a few years ago. If you are intrigued by any of this, it's well worth getting into!




## The simplest model of population growth

And an introduction to `for` loops


```{r}
x_0 <- 10
r = 1.1

```


```{r}
x_1 <- r * x_0
x_2 <- r * x_1
x_3 <- r * x_2
```


```{r}
x_3
```


```{r}
T <- 50
x <- numeric(T)
x[1] <- 10

```


```{r}
x[1] <- r * x[1]
x[2] <- r * x[1]
x[3] <- r * x[2]
x[4] <- r * x[3]
x[5] <- r * x[4]

x[3]
```



```{r}
x <- numeric(T)
x[1] <- 1
for(t in 1:(T-1) ){
    x[t+1] <- r * x[t] 
}
```



```{r}
table <- data_frame(time = 1:T, 
                    population = x)
table
```


```{r}
table %>% ggplot(aes(time, population)) + geom_line()
```


### Introducing custom R functions


```{r}
f <- function(squirrels, r){
  r * squirrels
  }
```


```{r}
f(x[1], 1.1)
```



```{r}
T <- 10000
x <- numeric(T)
x[1] = 10
for(t in 1:(T-1)){
    x[t+1] <- f(x[t], 1.5)
}
x[T]
```




## Adding density dependence


```{r}
f <- function(x, r = 1.1, K = 100){
  x + x * r * (1 - x / K)
}

f(20, r = 1, K = 100)
```



```{r}
simulate <- function(x_0 = 10, T = 20, r = 1, K = 100){
  
    # initialize
    x <- numeric(T)
    x[1] <- x_0
    
    # simulate
    for(t in 1:(T-1)){
        x[t+1] <- f(x[t], r, K)
    }
        
    # return results as a tibble
    data_frame(time = 1:T,
               population = x)

}
```


```{r}
simulate(K = 20, T = 20) %>%
  ggplot(aes(time, population)) + 
  geom_line()
```





```{r}
simulate(r = 2.1, K = 100) %>% 
  ggplot(aes(time, population)) + 
  geom_line()
```



-----------------------

## < Break for student independent exploration  of r & K values > 





```{r}
simulate(r=2.5, T = 20) %>% 
ggplot(aes(time, population)) + geom_line()
```



## Getting some intution for what's going on


```{r}
K  <- 100
r <- 2.1
x <- seq(0.0, 1.6 * K, len=100)

## needs to be a tibble
data_frame(`x[t]` = x, `x[t+1]` = f(x,r,K), y = x)  %>%
  ggplot(aes(`x[t]`,`x[t+1]`)) + 
  geom_line() + 
  geom_line(aes(y=y), lty=2)

```




```{r}
cobweb <- function(Iter = 2, r = 2.678, K = 100){


## needs to be a tibble
p1 <- data_frame(x0 = x, x1 = f(x,r,K), y = x)  %>%
  ggplot(aes(x0, x1)) + 
  geom_line() + 
  geom_line(aes(y=y), lty=2)
  
  # intial condition
  x0 <- 0.2 * K

  for(i in 1:Iter){
    
    x1 <- f(x0, r, K)
    df <- tribble(~x0, ~x1,
                  x0,  x0, # start
                  x0,  x1, # up
                  x1,  x1) # over
    
    p1 <- p1 + geom_line(data = df, col = "red")
    x0 <- x1
  }
  
  p1
}

cobweb(2, r = .9, K = 100)
# Plot the lines all at once

```

```{r}
cobweb(10, .9, 100)
```


```{r}
cobweb(20, 2.6, 100)
```

Bifurcation diagram


```{r}
# Establish the arrays to hold the set of iterates at each parameter value
K <- 100
r_range <- seq(1.9, 3.0, len=400)

burnin <- 500
T <- 250
rsweep <- numeric(T)
x <- numeric(T)


# Sweep the control parameter over the desired range
df <- map_df(r_range, function(r){
	# Set the initial condition to the reference value
	state <- 0.2 * K
	# Throw away the transient iterations
	for(i in 1:burnin){
		state <- f(state,r, K)
	  # Now store the next batch of iterates
	  for(j in 1:T){
		  state <- f(state, r, K)
		  rsweep[j] <- r
		  x[j] <- state
	  }
	}
	data_frame(r = rsweep, x = x)
})
```

```{r}
df %>%
ggplot(aes(r, x)) + geom_point(size=0.1)
```




